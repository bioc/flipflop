# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -I../linalg -DNDEBUG -o spams.cpp spams.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))

if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


##setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

##setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}

#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################


setClass('C++Reference', contains = 'ExternalReference')

## setMethod('[', "ExternalReference",
## function(x,i,j, ..., drop=TRUE) 
## if (!is.null(x$"__getitem__")) 
## sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

## setMethod('[<-' , "ExternalReference",
## function(x,i,j, ..., value) 
## if (!is.null(x$"__setitem__")) {
## sapply(1:length(i), function(n) 
## x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
## x
## })

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})

# Start of multLeftDiag

`multLeftDiag` = function(X, Y, XY)
{
  ;.Call('R_swig_multLeftDiag', X, Y, XY, PACKAGE='flipflop');
  
}

attr(`multLeftDiag`, 'returnType') = 'void'
attr(`multLeftDiag`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t')
class(`multLeftDiag`) = c("SWIGFunction", class('multLeftDiag'))

# Start of fistaFlat

`fistaFlat` = function(X, D, alpha0, alpha, num_threads, max_it, L0, fixed_step, gamma, s_lambda, delta, lambda2, lambda3, a, b, c, tol, it0, max_iter_backtracking, compute_gram, lin_admm, admm, intercept, resetflow, name_regul, name_loss, verbose, pos, clever, log, ista, subgrad, logName, is_inner_weights, inner_weights, size_group, sqrt_step, transpose, linesearch_mode)
{
  num_threads = as.integer(num_threads); 
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  max_it = as.integer(max_it); 
  
  if(length(max_it) > 1) {
    warning("using only the first element of max_it");
  };
  
  
  fixed_step = as.logical(fixed_step);
  
  
  
  
  
  
  
  
  
  it0 = as.integer(it0); 
  
  if(length(it0) > 1) {
    warning("using only the first element of it0");
  };
  
  max_iter_backtracking = as.integer(max_iter_backtracking); 
  
  if(length(max_iter_backtracking) > 1) {
    warning("using only the first element of max_iter_backtracking");
  };
  
  compute_gram = as.logical(compute_gram);
  lin_admm = as.logical(lin_admm);
  admm = as.logical(admm);
  intercept = as.logical(intercept);
  resetflow = as.logical(resetflow);
  name_regul = as(name_regul, "character"); 
  name_loss = as(name_loss, "character"); 
  verbose = as.logical(verbose);
  pos = as.logical(pos);
  clever = as.logical(clever);
  log = as.logical(log);
  ista = as.logical(ista);
  subgrad = as.logical(subgrad);
  logName = as(logName, "character"); 
  is_inner_weights = as.logical(is_inner_weights);
  
  size_group = as.integer(size_group); 
  
  if(length(size_group) > 1) {
    warning("using only the first element of size_group");
  };
  
  sqrt_step = as.logical(sqrt_step);
  transpose = as.logical(transpose);
  linesearch_mode = as.integer(linesearch_mode); 
  
  if(length(linesearch_mode) > 1) {
    warning("using only the first element of linesearch_mode");
  };
  
  ;ans = .Call('R_swig_fistaFlat', X, D, alpha0, alpha, num_threads, max_it, L0, fixed_step, gamma, s_lambda, delta, lambda2, lambda3, a, b, c, tol, it0, max_iter_backtracking, compute_gram, lin_admm, admm, intercept, resetflow, name_regul, name_loss, verbose, pos, clever, log, ista, subgrad, logName, is_inner_weights, inner_weights, size_group, sqrt_step, transpose, linesearch_mode, PACKAGE='flipflop');
  class(ans) <- "_p_MatrixT_double_t";
  
  ans
  
}

attr(`fistaFlat`, 'returnType') = '_p_MatrixT_double_t'
attr(`fistaFlat`, "inputTypes") = c('_p_MatrixT_double_t', '_p_AbstractMatrixBT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t', 'integer', 'integer', 'numeric', 'logical', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'integer', 'integer', 'logical', 'logical', 'logical', 'logical', 'logical', 'character', 'character', 'logical', 'logical', 'logical', 'logical', 'logical', 'logical', 'character', 'logical', '_p_VectorT_double_t', 'integer', 'logical', 'logical', 'integer')
class(`fistaFlat`) = c("SWIGFunction", class('fistaFlat'))


# Start of evalPathCoding

`evalPathCoding` = function(alpha0, dual_val, precision, weights, ir, jc, start_weights, stop_weights, num_threads, lambda1, lambda2, intercept, resetflow, name_regul, verbose, pos, clever, eval, eval_dual, size_group, transpose)
{
  if(length(precision) > 1) {
    warning("using only the first element of precision");
  };
  
  
  ir = as.integer(ir); 
  jc = as.integer(jc); 
  
  
  num_threads = as.integer(num_threads); 
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  
  
  intercept = as.logical(intercept);
  resetflow = as.logical(resetflow);
  name_regul = as(name_regul, "character"); 
  verbose = as.logical(verbose);
  pos = as.logical(pos);
  clever = as.logical(clever);
  eval = as.logical(eval);
  eval_dual = as.logical(eval_dual);
  size_group = as.integer(size_group); 
  
  if(length(size_group) > 1) {
    warning("using only the first element of size_group");
  };
  
  transpose = as.logical(transpose);
  ;ans = .Call('R_swig_evalPathCoding', alpha0, dual_val, precision, weights, ir, jc, start_weights, stop_weights, num_threads, lambda1, lambda2, intercept, resetflow, name_regul, verbose, pos, clever, eval, eval_dual, size_group, transpose, PACKAGE='flipflop');
  class(ans) <- "_p_SpMatrixT_double_t";
  
  ans
  
}

attr(`evalPathCoding`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`evalPathCoding`, "inputTypes") = c('_p_MatrixT_double_t', '_p_VectorT_double_t', 'integer', 'numeric', 'integer', 'integer', 'numeric', 'numeric', 'integer', 'numeric', 'numeric', 'logical', 'logical', 'character', 'logical', 'logical', 'logical', 'logical', 'logical', 'integer', 'logical')
class(`evalPathCoding`) = c("SWIGFunction", class('evalPathCoding'))

# Start of sepCostsPathCoding

`sepCostsPathCoding` = function(alpha0, alpha, weights, ir, jc, start_weights, stop_weights, max_capacity, epsilon_flow, prices, num_threads, lambda, tol, delta, loss_weights, name_regul, name_loss, pos, mode_decomposition)
{
  ir = as.integer(ir); 
  jc = as.integer(jc); 
  
  
  
  
  
  num_threads = as.integer(num_threads); 
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  
  
  
  
  name_regul = as(name_regul, "character"); 
  name_loss = as(name_loss, "character"); 
  pos = as.logical(pos);
  mode_decomposition = as.integer(mode_decomposition); 
  
  if(length(mode_decomposition) > 1) {
    warning("using only the first element of mode_decomposition");
  };
  
  ;ans = .Call('R_swig_sepCostsPathCoding', alpha0, alpha, weights, ir, jc, start_weights, stop_weights, max_capacity, epsilon_flow, prices, num_threads, lambda, tol, delta, loss_weights, name_regul, name_loss, pos, mode_decomposition, PACKAGE='flipflop');
  class(ans) <- "_p_SpMatrixT_double_t";
  
  ans
  
}

attr(`sepCostsPathCoding`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`sepCostsPathCoding`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', 'numeric', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'numeric', '_p_VectorT_double_t', 'integer', 'numeric', 'numeric', 'numeric', 'numeric', 'character', 'character', 'logical', 'integer')
class(`sepCostsPathCoding`) = c("SWIGFunction", class('sepCostsPathCoding'))

# Start of solverPoisson

`solverPoisson` = function(y, X, beta0, beta, weights, delta, max_iter, tol)
{
  max_iter = as.integer(max_iter); 
  
  if(length(max_iter) > 1) {
    warning("using only the first element of max_iter");
  };
  
  
  ;.Call('R_swig_solverPoisson', y, X, beta0, beta, weights, delta, max_iter, tol, PACKAGE='flipflop');
  
}

attr(`solverPoisson`, 'returnType') = 'void'
attr(`solverPoisson`, "inputTypes") = c('_p_VectorT_double_t', '_p_SpMatrixT_double_t', '_p_VectorT_double_t', '_p_VectorT_double_t', '_p_VectorT_double_t', 'numeric', 'integer', 'numeric')
class(`solverPoisson`) = c("SWIGFunction", class('solverPoisson'))

# Start of solverPoissonFull

`solverPoissonFull` = function(y, X, beta0, beta, weights, delta, max_iter, tol)
{
  max_iter = as.integer(max_iter); 
  
  if(length(max_iter) > 1) {
    warning("using only the first element of max_iter");
  };
  
  
  ;.Call('R_swig_solverPoissonFull', y, X, beta0, beta, weights, delta, max_iter, tol, PACKAGE='flipflop');
  
}

attr(`solverPoissonFull`, 'returnType') = 'void'
attr(`solverPoissonFull`, "inputTypes") = c('_p_VectorT_double_t', '_p_MatrixT_double_t', '_p_VectorT_double_t', '_p_VectorT_double_t', '_p_VectorT_double_t', 'numeric', 'integer', 'numeric')
class(`solverPoissonFull`) = c("SWIGFunction", class('solverPoissonFull'))
